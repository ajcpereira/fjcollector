from grafanalib.core import *
from grafanalib.influxdb import *
from grafanalib._gen import DashboardEncoder
import json, requests, logging
from functions_core.yaml_validate import *


def get_dashboard_json(dashboard, overwrite=False, message="Updated by grafanlib"):
    '''
    get_dashboard_json generates JSON from grafanalib Dashboard object

    :param dashboard - Dashboard() created via grafanalib
    '''

    # grafanalib generates json which need to pack to "dashboard" root element
    return json.dumps(
        {
            "dashboard": dashboard.to_json_data(),
            "overwrite": overwrite,
            "message": message
        }, sort_keys=True, indent=2, cls=DashboardEncoder)


def upload_to_grafana(json_data, server, api_key, verify=True):
    '''
    upload_to_grafana tries to upload dashboard to grafana and prints response

    :param json_data - dashboard json generated by grafanalib
    :param server - grafana server name
    :param api_key - grafana api key with read and write privileges
    '''

    headers = {'Authorization': f"Bearer {api_key}", 'Content-Type': 'application/json'}

    try:
        r = requests.post(f"http://{server}/api/dashboards/db", data=json_data, headers=headers, verify=verify)
        logging.debug("Message from fungraph %s" % r.json())
    except Exception as msgerror:
        logging.error("Failed to create report in grafana %s with error %s" % (server, msgerror))


def create_system_dashboard(sys, config):
    panels = []
    templating = []
    y_pos = 3

    panels = panels + create_title_panel(str(sys['system']))

    for res in sys['resources']:
        match res['name']:
            case "linux_os":
                y_pos, res_panel = create_panel_linux_os(str(sys['system']), str(res['name']), res['data'], sys['poll'], y_pos)
                panels = panels + res_panel
            case "eternus_cs8000":
                y_pos, res_panel = create_panel_eternus_cs8000(str(sys['system']), str(res['name']), res['data'], sys['poll'], y_pos)
                templating = create_dashboard_vars(res['data'])
                panels = panels + res_panel

    my_dashboard = Dashboard(
        title="System " + sys['system'] + " dashboard",
        description="fjcollector auto generated dashboard",
        tags=[
            sys['system'],
        ],
        timezone="browser",
        refresh="1m",
        panels=panels,
        templating=templating,
    ).auto_panel_ids()

    return my_dashboard


########################################################################################################################
#
# function: build_dashboards
#
# This function builds a grafana dashboard based on the monitored items, configured on the config.yaml file.
########################################################################################################################

def build_dashboards(config):
    # Dashboards will not be overwrited anymore

    logging.debug("Will build dashboards")
    grafana_api_key = config.global_parameters.grafana_api_key
    grafana_server = config.global_parameters.grafana_server + ":3000"

    systems = build_grafana_fun_data_model(config)

    for sys in systems:
        my_dashboard = create_system_dashboard(sys, config)
        my_dashboard_json = get_dashboard_json(my_dashboard, overwrite=True, message="Updated by fjcollector")
        logging.debug("Created dashboard %s", my_dashboard_json)
        upload_to_grafana(my_dashboard_json, grafana_server, grafana_api_key)


########################################################################################################################
#
# Resource Type: linux_os
#
########################################################################################################################


def create_panel_linux_os(system_name, resource_name, data, poll, global_pos):
    # todo:

    panels_list = []
    y_pos = global_pos

    for metric in data:
        match metric['metric']:
            case "cpu":
                y_pos, panel = cpu_graph_linux(system_name, resource_name, metric, y_pos)
                panels_list = panels_list + panel

            case "mem":
                y_pos, panel = mem_graph_linux(system_name, resource_name, metric, y_pos)
                panels_list = panels_list + panel

            case "fs":
                y_pos, panel = fs_graph_linux(system_name, resource_name, metric, y_pos)
                panels_list = panels_list + panel

            case "net":
                y_pos, panel = net_graph_linux(system_name, resource_name, metric, y_pos)
                panels_list = panels_list + panel

    return y_pos, panels_list


########################################################################################################################
#
# Resource Type: eternus_cs8000
#
########################################################################################################################

def create_panel_eternus_cs8000(system_name, resource_name, data, poll, global_pos):
    panels_list = []
    y_pos = global_pos

    for metric in data:
        match metric['metric']:
            case "fs_io":
                y_pos, panel = graph_eternus_cs8000_fs_io(system_name, resource_name, metric, y_pos)
                panels_list = panels_list + panel

            case "drives":
                y_pos, panel = graph_eternus_cs8000_drives(system_name, resource_name, metric, y_pos)
                panels_list = panels_list + panel

            case "medias":
                y_pos, panel = eternus_cs8000_medias_graph(system_name, resource_name, metric, y_pos)
                panels_list = panels_list + panel

            case "pvgprofile":
                y_pos, panel = eternus_cs8000_pvgprofile_graph(system_name, resource_name, metric, y_pos)
                panels_list = panels_list + panel

            case "fc":
                y_pos, panel = eternus_cs8000_fc_graph(system_name, resource_name, metric, y_pos)
                panels_list = panels_list + panel

            case "cpu":
                y_pos, panel = cpu_graph_linux(system_name,resource_name, metric, y_pos)
                panels_list = panels_list + panel

            case "mem":
                y_pos, panel = mem_graph_linux(system_name, resource_name, metric, y_pos)
                panels_list = panels_list + panel

            case "fs":
                y_pos, panel = fs_graph_linux(system_name, resource_name, metric, y_pos)
                panels_list = panels_list + panel

            case "net":
                y_pos, panel = net_graph_linux(system_name, resource_name, metric, y_pos)
                panels_list = panels_list + panel

    return y_pos, panels_list


########################################################################################################################
#
# Resource Type: create_title_panel
#
########################################################################################################################
def create_title_panel(system_name):
    str_msg = "<br><p style=\"text-align:center\"><span style=\"font-size:36px\">System " + system_name + "</span></p>"

    panel = [Text(
        title="",
        gridPos=GridPos(h=3, w=24, x=0, y=0),
        mode="html",
        content=str_msg,
    )]

    return panel


def cpu_graph_linux(system_name,resource_name,metric, y_pos):


    panels_list = [RowPanel(title=resource_name + ': CPU', gridPos=GridPos(h=1, w=24, x=0, y=y_pos))]
    line = y_pos + 1

    panels_target_list_cpu_use = []
    for host in metric['hosts']:
        panels_target_list_cpu_use = panels_target_list_cpu_use + [InfluxDBTarget(
            query="SELECT use FROM cpu WHERE $timeFilter AND (\"host\"::tag = '" + host +
                  "') AND (\"system\"::tag = '" + system_name + "') GROUP BY \"host\"::tag",
            alias="$tag_host")]

    panels_list.append(TimeSeries(
        title="CPU utilization (%)",
        dataSource='default',
        targets=panels_target_list_cpu_use,
        drawStyle='line',
        lineInterpolation='smooth',
        gradientMode='hue',
        fillOpacity=25,
        unit="percent",
        gridPos=GridPos(h=7, w=12, x=0, y=line),
        spanNulls=True,
        legendPlacement="right",
        legendDisplayMode="table"
    ))

    panels_target_list_cpu_load = []
    for host in metric['hosts']:
        panels_target_list_cpu_load = panels_target_list_cpu_load + [InfluxDBTarget(
            query="SELECT \"load5m\" FROM \"cpu\" WHERE $timeFilter AND (\"host\"::tag = '" + host +
                  "') AND (\"system\"::tag = '" + system_name + "') GROUP BY \"host\"::tag",
            alias="$tag_host")]

    panels_list.append(TimeSeries(
        title="CPU Average Load (5 min)",
        dataSource='default',
        targets=panels_target_list_cpu_load,
        drawStyle='line',
        lineInterpolation='smooth',
        gradientMode='hue',
        fillOpacity=25,
        unit="",
        gridPos=GridPos(h=7, w=12, x=12, y=line),
        spanNulls=True,
        legendPlacement="right",
        legendDisplayMode="table"
    ))

    line = line + 7

    return line, panels_list


def mem_graph_linux(system_name, resource_name, metric, y_pos):

    panels_list = [RowPanel(title=resource_name + ': Memory', gridPos=GridPos(h=1, w=24, x=0, y=y_pos))]
    pos = y_pos + 1

    target_mem = [InfluxDBTarget(
        query="SELECT  (total)-(avail) as \"Used\", (avail) as \"Available\" FROM \"mem\" WHERE $timeFilter AND (\"system\"::tag = '" + system_name + "') GROUP BY \"host\"::tag ORDER BY time DESC LIMIT 1",
        format="table")]

    panels_list.append(BarChart(
        title="Memory Usage",
        dataSource='default',
        targets=target_mem,
        drawStyle='line',
        lineInterpolation='smooth',
        gradientMode='hue',
        fillOpacity=25,
        unit="decmbytes",
        gridPos=GridPos(h=7, w=24, x=0, y=pos),
        spanNulls=True,
        legendPlacement="right",
        legendDisplayMode="table",
        stacking={'mode': "normal"},
        tooltipMode="multi",
    ))

    pos = pos + 7

    return pos, panels_list


def fs_graph_linux(system_name,resource_name,metric, y_pos):

    panels_list = [RowPanel(title=resource_name + ': File System', gridPos=GridPos(h=1, w=24, x=0, y=y_pos))]
    pos = y_pos + 1

    for host in metric['hosts']:
        target_fs = [InfluxDBTarget(
            #query="SELECT used as Used, total-used as Available FROM fs WHERE $timeFilter AND (\"host\"::tag = '" + host + "') AND (\"system\"::tag = '" + system_name + "') GROUP BY \"mount\"::tag ORDER BY time DESC LIMIT 1",
            query="SELECT \"used\" as \"Used\", \"total\"-\"used\" as \"Available\", \"total\" as \"Total\", \"used\"/\"total\"*100 as \"%Used\" FROM \"fs\" WHERE $timeFilter AND ( \"system\"::tag = '" + system_name + "' AND \"host\"::tag = '" + host + "') GROUP BY \"mount\"::tag ORDER BY time DESC LIMIT 1",
            format="table")]

        overrides_lst = [
          {
            "matcher": {
              "id": "byName",
              "options": "%Used"
            },
            "properties": [
              {
                "id": "unit",
                "value": "percent"
              },
              {
                "id": "custom.hideFrom",
                "value": {
                  "tooltip": False,
                  "viz": True,
                  "legend": True
                }
              }
            ]
          },
          {
            "matcher": {
              "id": "byName",
              "options": "Total"
            },
            "properties": [
              {
                "id": "custom.hideFrom",
                "value": {
                  "tooltip": False,
                  "viz": True,
                  "legend": True
                }
              }
            ]
          }
        ]

        panels_list.append(BarChart(
            title=host + " Filesystem",
            dataSource='default',
            targets=target_fs,
            drawStyle='line',
            lineInterpolation='smooth',
            gradientMode='hue',
            fillOpacity=25,
            unit="deckbytes",
            gridPos=GridPos(h=7, w=24, x=0, y=pos),
            spanNulls=True,
            legendPlacement="right",
            legendDisplayMode="table",
            stacking={'mode': "normal"},
            tooltipMode="multi",
            xTickLabelRotation=-45,
            decimals=2,
            overrides=overrides_lst,
        ))
        pos = pos + 7

    return pos, panels_list


def net_graph_linux(system_name,resource_name,metric, y_pos):


    panels_list = [RowPanel(title=resource_name + ': Network', gridPos=GridPos(h=1, w=24, x=0, y=y_pos))]
    pos = y_pos + 1

    for host in metric['hosts']:
        target_net_outbound = [InfluxDBTarget(
            query="SELECT non_negative_derivative(mean(\"tx_bytes\"), 1s) FROM \"net\" WHERE (\"system\"::tag = '" + system_name + "' AND \"host\"::tag = '" + host + "') AND $timeFilter GROUP BY time($__interval), \"if\"::tag fill(null)",
            alias="$tag_if")]

        panels_list.append(TimeSeries(
            title=host + " Network Outbound",
            dataSource='default',
            targets=target_net_outbound,
            drawStyle='line',
            lineInterpolation='smooth',
            gradientMode='hue',
            fillOpacity=25,
            unit="binBps",
            gridPos=GridPos(h=7, w=12, x=0, y=pos),
            spanNulls=True,
            legendPlacement="right",
            legendDisplayMode="table"
        ))

        target_net_inbound = [InfluxDBTarget(
            query="SELECT non_negative_derivative(mean(\"rx_bytes\"), 1s) FROM \"net\" WHERE (\"system\"::tag = '" + system_name + "' AND \"host\"::tag = '" + host + "') AND $timeFilter GROUP BY time($__interval), \"if\"::tag fill(null)",
            alias="$tag_if")]

        panels_list.append(TimeSeries(
            title=host + " Network Inbound",
            dataSource='default',
            targets=target_net_inbound,
            drawStyle='line',
            lineInterpolation='smooth',
            gradientMode='hue',
            fillOpacity=25,
            unit="binBps",
            gridPos=GridPos(h=7, w=12, x=12, y=pos),
            spanNulls=True,
            legendPlacement="right",
            legendDisplayMode="table"
        ))
        pos = pos + 7

    return pos, panels_list


def graph_eternus_cs8000_fs_io(system_name, resource_name, metric, y_pos):


    panels_list = [RowPanel(title=resource_name + ': CAFS IOSTAT', gridPos=GridPos(h=1, w=24, x=0, y=y_pos))]
    pos = y_pos + 1
    panel_width = 5
    penel_height = 14


    for host in metric['hosts']:
        panels_target_list = [InfluxDBTarget(
            query=("SELECT mean(\"svctm\") FROM \"fs_io\" WHERE (\"system\"::tag = '" + system_name +
                   "' AND \"host\"::tag = '" + host +
                   "') AND $timeFilter GROUP BY time($__interval), \"fs\"::tag, \"dm\"::tag, \"rawdev\"::tag fill(null)"),
            alias="$tag_fs $tag_dm $tag_rawdev")]




        panels_list.append(TimeSeries2(
            title=host + " Service Time",
            dataSource='default',
            targets=panels_target_list,
            drawStyle='line',
            lineInterpolation='smooth',
            gradientMode='hue',
            fillOpacity=25,
            unit="ms",
            gridPos=GridPos(h=penel_height, w=panel_width, x=0, y=pos),
            spanNulls=True,
            legendPlacement="bottom",
            legendDisplayMode="table",
            legendCalcs=["max", "mean"],
            legendSortBy="Max",
            legendSortDesc=True,
        ))

        panels_target_list = [InfluxDBTarget(
            query=("SELECT mean(\"r/s\") FROM \"fs_io\" WHERE (\"system\"::tag = '" + system_name +
                   "' AND \"host\"::tag = '" + host +
                   "') AND $timeFilter GROUP BY time($__interval), \"fs\"::tag, \"dm\"::tag, \"rawdev\"::tag fill(null)"),
            alias="$tag_fs $tag_dm $tag_rawdev")]

        panels_list.append(TimeSeries2(
            title=host + " Reads/s",
            dataSource='default',
            targets=panels_target_list,
            drawStyle='line',
            lineInterpolation='smooth',
            gradientMode='hue',
            fillOpacity=25,
            unit="iops",
            gridPos=GridPos(h=penel_height, w=panel_width, x=1 * panel_width, y=pos),
            spanNulls=True,
            legendPlacement="bottom",
            legendDisplayMode="table",
            legendCalcs=["max", "mean"],
            legendSortBy="Max",
            legendSortDesc=True,
        ))

        panels_target_list = [InfluxDBTarget(
            query=("SELECT mean(\"r_await\") FROM \"fs_io\" WHERE (\"system\"::tag = '" + system_name +
                   "' AND \"host\"::tag = '" + host +
                   "') AND $timeFilter GROUP BY time($__interval), \"fs\"::tag, \"dm\"::tag, \"rawdev\"::tag fill(null)"),
            alias="$tag_fs $tag_dm $tag_rawdev")]

        panels_list.append(TimeSeries2(
            title=host + " Read Average Wait Time",
            dataSource='default',
            targets=panels_target_list,
            drawStyle='line',
            lineInterpolation='smooth',
            gradientMode='hue',
            fillOpacity=25,
            unit="ms",
            gridPos=GridPos(h=penel_height, w=panel_width, x=2 * panel_width, y=pos),
            spanNulls=True,
            legendPlacement="bottom",
            legendDisplayMode="table",
            legendCalcs=["max", "mean"],
            legendSortBy="Max",
            legendSortDesc=True,
        ))

        panels_target_list = [InfluxDBTarget(
            query=("SELECT mean(\"w/s\") FROM \"fs_io\" WHERE (\"system\"::tag = '" + system_name +
                   "' AND \"host\"::tag = '" + host +
                   "') AND $timeFilter GROUP BY time($__interval), \"fs\"::tag, \"dm\"::tag, \"rawdev\"::tag fill(null)"),
            alias="$tag_fs $tag_dm $tag_rawdev")]

        panels_list.append(TimeSeries2(
            title=host + " Writes/s",
            dataSource='default',
            targets=panels_target_list,
            drawStyle='line',
            lineInterpolation='smooth',
            gradientMode='hue',
            fillOpacity=25,
            unit="iops",
            gridPos=GridPos(h=penel_height, w=panel_width, x=3 * panel_width, y=pos),
            spanNulls=True,
            legendPlacement="bottom",
            legendDisplayMode="table",
            legendCalcs=["max", "mean"],
            legendSortBy="Max",
            legendSortDesc=True,
        ))

        panels_target_list = [InfluxDBTarget(
            query=("SELECT mean(\"w_await\") FROM \"fs_io\" WHERE (\"system\"::tag = '" + system_name +
                   "' AND \"host\"::tag = '" + host +
                   "') AND $timeFilter GROUP BY time($__interval), \"fs\"::tag, \"dm\"::tag, \"rawdev\"::tag fill(null)"),
            alias="$tag_fs $tag_dm $tag_rawdev")]

        panels_list.append(TimeSeries2(
            title=host + " Write Average Wait Time",
            dataSource='default',
            targets=panels_target_list,
            drawStyle='line',
            lineInterpolation='smooth',
            gradientMode='hue',
            fillOpacity=25,
            unit="ms",
            gridPos=GridPos(h=penel_height, w=panel_width-1, x=4*panel_width, y=pos),
            spanNulls=True,
            legendPlacement="bottom",
            legendDisplayMode="table",
            legendCalcs=["max", "mean"],
            legendSortBy="Max",
            legendSortDesc=True,
        ))

        pos = pos + 7

    return pos, panels_list


def graph_eternus_cs8000_drives(system_name,resource_name,metric, y_pos):

    panels_list = [RowPanel(title=resource_name + ': Tape Libraries', gridPos=GridPos(h=1, w=24, x=0, y=y_pos))]
    line = y_pos + 1

    target_list = [InfluxDBTarget(
            query="SELECT \"used\" as Used, \"other\" as Other, \"total\" as Total FROM \"drives\" WHERE $timeFilter AND (\"system\"::tag = '" + system_name +
                  "') AND (\"tapename\"::tag =~ /^$tapename$/)")]


    panels_list.append(TimeSeries(
        title="Tape Library $tapename",
        repeat=Repeat(direction='h', variable='tapename',maxPerRow=6),
        dataSource='default',
        targets=target_list,
        drawStyle='line',
        lineInterpolation='stepAfter',
        gradientMode='hue',
        fillOpacity=25,
        unit='',
        gridPos=GridPos(h=7, w=12, x=0, y=line),
        spanNulls=True,
        legendPlacement='right',
        legendDisplayMode='table',
    ))

    line = line + 7

    return line, panels_list


def eternus_cs8000_medias_graph(system_name, resource_name, metric, y_pos):

    panels_list = [RowPanel(title=resource_name + ': Tape Medias', gridPos=GridPos(h=1, w=24, x=0, y=y_pos))]
    line = y_pos + 1

    target_list = [InfluxDBTarget(
        query="SELECT  \"Total Cap GiB\", \"Total Clean Medias\", \"Total Fault\", \"Total Ina\", \"Total Medias\", \"Total Val GiB\", \"Val %\"  FROM \"medias\" WHERE $timeFilter AND (\"system\"::tag='" + system_name + "') GROUP BY \"host\"::tag, \"tapename\"::tag ORDER BY DESC LIMIT 1",
        format="table")]

    override_lst = [
      {
        "matcher": {
          "id": "byName",
          "options": "Time"
        },
        "properties": [
          {
            "id": "custom.hidden",
            "value": True
          }
        ]
      },
      {
        "matcher": {
          "id": "byName",
          "options": "Total Cap GiB"
        },
        "properties": [
          {
            "id": "unit",
            "value": "decgbytes"
          }
        ]
      },
      {
        "matcher": {
          "id": "byName",
          "options": "Total Val GiB"
        },
        "properties": [
          {
            "id": "unit",
            "value": "decgbytes"
          }
        ]
      },
      {
        "matcher": {
          "id": "byName",
          "options": "Val %"
        },
        "properties": [
          {
            "id": "unit",
            "value": "percent"
          },
          {
            "id": "thresholds",
            "value": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "green",
                  "value": None
                },
                {
                  "color": "#EAB839",
                  "value": 65
                },
                {
                  "color": "red",
                  "value": 75
                }
              ]
            }
          }
        ]
      }
    ]

    thres = [
        {
            "color": "text",
            "value": None
        }
    ]

    panels_list.append(Table(
        title="Tape Medias",
        dataSource='default',
        targets=target_list,
        gridPos=GridPos(h=7, w=24, x=0, y=line),
        filterable=True,
        displayMode="color-text",
        colorMode="thresholds",
        overrides=override_lst,
        #thresholds=Threshold('black', 0, 0.0),
        thresholds=thres,
    ))

    line = line + 7

    return line, panels_list


def eternus_cs8000_pvgprofile_graph(system_name, resource_name, metric, y_pos):

    panels_list = [RowPanel(title=resource_name + ': Physical Volume Group Profile', gridPos=GridPos(h=1, w=24, x=0, y=y_pos))]
    line = y_pos + 1

    target_list = [InfluxDBTarget(
        query= "SELECT \"Total Medias\", \"Fault\", \"Ina\", \"Scr\", \"-10\", \"-20\", \"-30\", \"-40\", \"-50\", \"-60\", \"-70\", \"-80\", \"-90\", \">90\", \"Total Cap (GiB)\", \"Total Used (GiB)\" from pvgprofile WHERE $timeFilter AND (\"system\"::tag='" + system_name + "') GROUP BY \"pvgname\"::tag, \"host\"::tag ORDER BY DESC LIMIT 1",
        format="table")]

    override_lst = [
        {
            "matcher": {
                "id": "byName",
                "options": "Time"
            },
            "properties": [
                {
                    "id": "custom.hidden",
                    "value": True
                }
            ]
        },
        {
            "matcher": {
                "id": "byName",
                "options": "Scr"
            },
            "properties": [
                {
                    "id": "thresholds",
                    "value": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": None
                            },
                            {
                                "color": "red",
                                "value": 0
                            },
                            {
                                "color": "#EAB839",
                                "value": 10
                            },
                            {
                                "color": "green",
                                "value": 15
                            }
                        ]
                    }
                }
            ]
        },
        {
            "matcher": {
                "id": "byName",
                "options": "Total Cap (GiB)"
            },
            "properties": [
                {
                    "id": "unit",
                    "value": "decgbytes"
                }
            ]
        },
        {
            "matcher": {
                "id": "byName",
                "options": "Total Used (GiB)"
            },
            "properties": [
                {
                    "id": "unit",
                    "value": "decgbytes"
                }
            ]
        }
    ]

    thres = [
          {
            "color": "text",
            "value": None
          }
        ]


    panels_list.append(Table(
        title="Physical Volume Group",
        dataSource='default',
        targets=target_list,
        gridPos=GridPos(h=7, w=24, x=0, y=line),
        filterable=True,
        displayMode="color-text",
        colorMode="thresholds",
        overrides=override_lst,
        #thresholds=Threshold(line=False,color='text', index=0, value=0.0, op=EVAL_GT),
        thresholds=thres,
        fontSize="85%",
    ))

    line = line + 7

    return line, panels_list


def eternus_cs8000_fc_graph(system_name, resource_name, metric, y_pos):


    panels_list = [RowPanel(title=resource_name + ': FC', gridPos=GridPos(h=1, w=24, x=0, y=y_pos))]
    pos = y_pos + 1

    for host in metric['hosts']:
        target_net_outbound = [InfluxDBTarget(
            query = "SELECT non_negative_derivative(mean(\"tx_bytes\"), 1s) FROM \"fc\" WHERE (\"system\"::tag = '" + system_name + "' AND \"host\"::tag = '" + host + "') AND $timeFilter GROUP BY time($__interval), \"hba\"::tag fill(null)",
            alias="$tag_hba")]


        panels_list.append(TimeSeries(
            title=host + " FC Outbound",
            dataSource='default',
            targets=target_net_outbound,
            drawStyle='line',
            lineInterpolation='smooth',
            gradientMode='hue',
            fillOpacity=25,
            unit="binBps",
            gridPos=GridPos(h=7, w=12, x=0, y=pos),
            spanNulls=True,
            legendPlacement="right",
            legendDisplayMode="table"
        ))

        target_net_inbound = [InfluxDBTarget(
            query="SELECT non_negative_derivative(mean(\"rx_bytes\"), 1s) FROM \"fc\" WHERE (\"system\"::tag = '" + system_name + "' AND \"host\"::tag = '" + host + "') AND $timeFilter GROUP BY time($__interval), \"hba\"::tag fill(null)",
            alias="$tag_hba")]

        panels_list.append(TimeSeries(
            title=host + " FC Inbound",
            dataSource='default',
            targets=target_net_inbound,
            drawStyle='line',
            lineInterpolation='smooth',
            gradientMode='hue',
            fillOpacity=25,
            unit="binBps",
            gridPos=GridPos(h=7, w=12, x=12, y=pos),
            spanNulls=True,
            legendPlacement="right",
            legendDisplayMode="table"
        ))
        pos = pos + 7

    return pos, panels_list



def create_dashboard_vars(data):

    tpl_lst = []

    for metric in data:
        match metric['metric']:
            case "drives":
                tpl_lst = tpl_lst + [ Template(
                    #dataSource="default",
                    name='tapename',
                    label='tapename',
                    query='SHOW TAG VALUES WITH KEY = \"tapename\"',
                    type='query',
                    includeAll=True,
                    multi=True,
                    allValue=True,
                    default='All',
                    refresh=2,
                    hide=HIDE_VARIABLE,
                ) ]

    return Templating(tpl_lst)

########################################################################################################################
#
# Class: BarChart
#
# Grafanalib doesn't have a class to manipulate BarChart
# this is a new class, based on TimeSeries class, to create BarChart graphs
########################################################################################################################
@attr.s
class BarChart(TimeSeries):

    def __init__(self, xTickLabelRotation, decimals,**kwargs):
        super().__init__(self, **kwargs)
        self.xTickLabelRotation = xTickLabelRotation
        self.decimals = decimals

    xTickLabelRotation = attr.ib(default=0, validator=instance_of(int))
    decimals = attr.ib(default=0, validator=instance_of(int))

    def to_json_data(self):
        return self.panel_json(
            {
                'fieldConfig': {
                    'defaults': {
                        'color': {
                            'mode': self.colorMode
                        },
                        'custom': {
                            'axisPlacement': self.axisPlacement,
                            'axisLabel': self.axisLabel,
                            'drawStyle': self.drawStyle,
                            'lineInterpolation': self.lineInterpolation,
                            'barAlignment': self.barAlignment,
                            'lineWidth': self.lineWidth,
                            'fillOpacity': self.fillOpacity,
                            'gradientMode': self.gradientMode,
                            'spanNulls': self.spanNulls,
                            'showPoints': self.showPoints,
                            'pointSize': self.pointSize,
                            'scaleDistribution': {
                                'type': self.scaleDistributionType,
                                'log': self.scaleDistributionLog
                            },
                            'hideFrom': {
                                'tooltip': False,
                                'viz': False,
                                'legend': False
                            },
                            'thresholdsStyle': {
                                'mode': self.thresholdsStyleMode
                            },
                        },
                        'mappings': self.mappings,
                        'unit': self.unit,
                        'decimals': self.decimals,
                    },
                    'overrides': self.overrides
                },
                'options': {
                    'stacking': self.stacking,
                    'xTickLabelRotation': self.xTickLabelRotation,
                    'legend': {
                        'displayMode': self.legendDisplayMode,
                        'placement': self.legendPlacement,
                        'calcs': self.legendCalcs
                    },
                    'tooltip': {
                        'mode': self.tooltipMode
                    }
                },
                'type': "barchart",
            })


########################################################################################################################
#
# Class: TimeSeries2
#
# Grafanalib TimeSeries class doesn't have the attribute for sorting the legend
# this is a new class, based on TimeSeries class, that adds the above funcionality
#######################################################################################################################
@attr.s
class TimeSeries2(TimeSeries):

    def __init__(self, xTickLabelRotation, legendSortBy, legendSortDesc, **kwargs):
        super().__init__(self, **kwargs)
        self.xTickLabelRotation = xTickLabelRotation
        self.legendSortBy = legendSortBy
        self.legendSortDesc = legendSortDesc

    xTickLabelRotation = attr.ib(default=0, validator=instance_of(int))
    legendSortBy = attr.ib(default='max', validator=instance_of(str))
    legendSortDesc = attr.ib(default=False, validator=instance_of(bool))

    def to_json_data(self):
        return self.panel_json(
            {
                'fieldConfig': {
                    'defaults': {
                        'color': {
                            'mode': self.colorMode
                        },
                        'custom': {
                            'axisPlacement': self.axisPlacement,
                            'axisLabel': self.axisLabel,
                            'drawStyle': self.drawStyle,
                            'lineInterpolation': self.lineInterpolation,
                            'barAlignment': self.barAlignment,
                            'lineWidth': self.lineWidth,
                            'fillOpacity': self.fillOpacity,
                            'gradientMode': self.gradientMode,
                            'spanNulls': self.spanNulls,
                            'showPoints': self.showPoints,
                            'pointSize': self.pointSize,
                            'scaleDistribution': {
                                'type': self.scaleDistributionType,
                                'log': self.scaleDistributionLog
                            },
                            'hideFrom': {
                                'tooltip': False,
                                'viz': False,
                                'legend': False
                            },
                            'thresholdsStyle': {
                                'mode': self.thresholdsStyleMode
                            },
                        },
                        'mappings': self.mappings,
                        'unit': self.unit
                    },
                    'overrides': self.overrides
                },
                'options': {
                    'stacking': self.stacking,
                    'xTickLabelRotation': self.xTickLabelRotation,
                    'legend': {
                        'displayMode': self.legendDisplayMode,
                        'placement': self.legendPlacement,
                        'calcs': self.legendCalcs,
                        'sortBy': self.legendSortBy,
                        'sortDesc': self.legendSortDesc,
                    },
                    'tooltip': {
                        'mode': self.tooltipMode
                    }
                },
                'type': "timeseries",
            })


########################################################################################################################
#
# function: build_grafana_fun_data_model
#
# This function builds a dictionary with the data model for creating the graphs
# This functions need rework!!!!!
########################################################################################################################


def build_grafana_fun_data_model(config):
    def check_if_metric_exists(system_name, resource_name, metric_name, lst):
        metrics_lst = []
        b_exists = False

        for x in lst:
            if system_name in x['system']:
                for y in x['resources']:
                    if resource_name == y['name']:
                        for z in y['data']:
                            if metric_name == z['metric']:
                                metrics_lst = z['hosts']
                                b_exists = True

        return b_exists, metrics_lst

    def check_if_system_exists(system_name, lst):

        b_result = False
        for x in lst:
            if system_name == x['system']:
                b_result = True

        return b_result

    def check_if_resource_exists(system_name, resource_name, lst):

        b_result = False
        for x in lst:
            if system_name == x['system']:
                for y in x['resources']:
                    if resource_name == y['name']:
                        b_result = True

        return b_result

    def my_update_resource_list(system_name, resource_name, metric_name, lst, dict_metric):

        for x in lst:
            if system_name == x['system']:
                for y in x['resources']:
                    if resource_name == y['name']:
                        for k in y['data']:
                            if metric_name == k['metric']:
                                k.update(dict_metric)

        return lst

    def add_resource(system_name, dict, model):

        local_model = model

        for x in local_model:
            if system_name in x['system']:
                x['resources'].append(dict)
                logging.debug(add_resource.__name__ + ": existing resources are %s", x)

        logging.debug(add_resource.__name__ + ": function result is %s", local_model)

        return local_model

    def my_add_metrics_to_existing_resource_list(system_name, resource_name, dict_metric, model):

        local_model = model

        for x in local_model:
            if system_name == x['system']:
                for y in x['resources']:
                    if resource_name == y['name']:
                        #y['data'].append(dict_metric[0])
                        y['data'] = y['data'] + dict_metric

        return local_model

    logging.debug(build_grafana_fun_data_model.__name__ + ": Config data is - %s", config)
    model_result = []

    try:
        for system in config.systems:
            metric_list = []
            res_list = []
            met_exists = False
            for metric in system.config.metrics:
                host_list = []
                for ip in system.config.ips:
                    #if not ip.alias is None:
                    if ip.alias is not None:
                        hostname = ip.alias
                    else:
                        hostname = str(ip.ip)
                    host_list.append(hostname)

                met_exists, met_hosts_lst = check_if_metric_exists(system.name, system.resources_types, metric.name,
                                                                   model_result)
                logging.debug(build_grafana_fun_data_model.__name__ + ": Existing metric %s and hosts %s", metric.name,
                              met_hosts_lst)
                logging.debug(build_grafana_fun_data_model.__name__ + ": Adding metric %s and hosts %s", metric.name,
                              host_list)
                if met_exists:
                    metric_dict = {"metric": metric.name, "hosts": met_hosts_lst + host_list}
                    logging.debug(build_grafana_fun_data_model.__name__ + ": New metric list %s ",
                                  metric_dict)

                    model_result = my_update_resource_list(system.name, system.resources_types, metric.name,
                                                           model_result, metric_dict)
                    logging.debug(build_grafana_fun_data_model.__name__ + ": New model result %s ",
                                  model_result)
                else:
                    metric_list.append({"metric": metric.name, "hosts": host_list})

                logging.debug(build_grafana_fun_data_model.__name__ + ": Metrics exist %s and metrics list is %s",
                              met_exists, metric_list)

            res_exists = check_if_resource_exists(system.name, system.resources_types, model_result)

            if res_exists and not met_exists:
                logging.debug(
                    build_grafana_fun_data_model.__name__ +
                    ": Resource exist=%s and metrics exist=%s metrics list is %s model_result %s",
                    res_exists, met_exists, metric_list, model_result)
                model_result = my_add_metrics_to_existing_resource_list(system.name, system.resources_types,
                                                                        metric_list, model_result)

            if not res_exists:
                logging.debug(
                    build_grafana_fun_data_model.__name__ + ": Resource %s do not exists but system %s exists",
                    system.resources_types, system.name)
                res_list.append({"name": system.resources_types, "data": metric_list})

            if check_if_system_exists(system.name, model_result) and not res_exists:
                logging.debug(build_grafana_fun_data_model.__name__ + ": System exists - %s", model_result)
                model_result = add_resource(system.name, {"name": system.resources_types, "data": metric_list},
                                            model_result)

            # System
            if not check_if_system_exists(system.name, model_result) and not res_exists:
                model_result.append(
                    {"system": system.name, "resources": res_list, "poll": system.config.parameters.poll})

            logging.debug(build_grafana_fun_data_model.__name__ + ": Model is - %s", model_result)
    except Exception as msgerror:
        logging.error(
            build_grafana_fun_data_model.__name__ +
            ": Unexpected error creating grafana_fun data model - %s" % msgerror)
        return -1

    logging.debug(build_grafana_fun_data_model.__name__ + ": grafana_fun data model is - %s", model_result)

    return model_result
